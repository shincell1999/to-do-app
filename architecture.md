Secure TODO App アーキテクチャ設計

1. 設計方針

本アプリは学習用途であるが、実務で再現性のある構成を意識する。
クリーンアーキテクチャの考え方を参考にしつつ、過剰な抽象化は行わない。

重視する点は以下の通り。
	•	責務を明確に分離し、変更理由を限定する
	•	セキュリティ上重要な処理（認証・認可）を集中管理する
	•	小規模アプリでもスケールを意識した構成にする

⸻

2. 全体構成（3層アーキテクチャ）

[ Frontend (React + TypeScript) ]
            ↓ HTTP (JSON)
[ Backend (Node.js + TypeScript) ]
            ↓ SQL
[ PostgreSQL ]

フロントエンドとバックエンドは完全に分離し、
バックエンドは API サーバーとして責務を限定する。

⸻

3. バックエンド内部構成

バックエンドは以下の層に分割する。

routes
  └─ リクエストの入口・ルーティングのみ
controllers
  └─ HTTPレベルの責務（req / res）
services
  └─ ビジネスロジック・認証認可判断
repositories
  └─ DBアクセス（SQL実行）

3.1 routes
	•	エンドポイントとHTTPメソッドを定義する
	•	認証ミドルウェアを適用する場所を明示する
	•	ロジックは持たない

3.2 controllers
	•	リクエストの入力値を受け取る
	•	バリデーション結果を判定する
	•	service を呼び出す
	•	HTTPステータスとレスポンス形式を決定する

3.3 services
	•	アプリケーションの中核ロジックを担当する
	•	認可（user_id の一致確認）を行う
	•	複数リポジトリを組み合わせる場合もこの層で行う

3.4 repositories
	•	DBアクセスのみを担当する
	•	生SQLを使用し、必ずプレースホルダを利用する
	•	user_id を条件に含め、データ分離を保証する

⸻

4. 認証・認可の配置

4.1 認証
	•	JWTの検証はミドルウェアで行う
	•	検証済みの user_id を request に付与する

4.2 認可
	•	controller では行わない
	•	service 層で user_id を使って判断する
	•	repository では user_id を WHERE 句に必ず含める

認可を1箇所に寄せず、
「service で論理チェック」「repository で物理制約」
の二重構造とする

⸻

5. エラーハンドリング方針
	•	想定内エラー（認証失敗、バリデーションエラー）は service で定義する
	•	controller で HTTP ステータスに変換する
	•	想定外エラーは共通エラーハンドラで処理する

⸻

6. なぜこの構成にしたか
	•	小規模アプリでも責務を分ける癖をつけるため
	•	認証・認可ロジックを散らさないため
	•	将来、ロール管理や監査ログを追加しやすくするため

⸻

7. あえて採用しなかった設計
	•	ドメイン層・ユースケース層の厳密な分離
	•	Repository Interface の過剰な抽象化
	•	DIコンテナの導入

学習初期段階では、
抽象化よりも「流れが追えること」を優先する

⸻

8. 将来拡張時の想定変更点
	•	ロール管理追加：service 層の拡張
	•	監査ログ追加：repository の追加
	•	認証方式変更：middleware の差し替え